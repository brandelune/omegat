<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE appendix PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
"../../../docbook-xml-4.5/docbookx.dtd"
[<!ENTITY % manualvariables SYSTEM "manualvariables.mod"> %manualvariables;]>

<section id="app.regexp">
  <title id="app.regexp.title">Regular expressions</title>

  <para>This appendix is intended for users interested in exploring a
  powerful way to boost their productivity. Although seen as daunting and
  complex, even the simplest regular expressions (often abbreviated
  <emphasis>regex</emphasis> or <emphasis>regexp</emphasis>) are extremely
  useful, not only in OmegaT, but in many other applications you might use
  on a day-to-day basis.</para>

  <para>Only the fundamentals most useful to translators are covered. The
  <link linkend="app.regex.tools" endterm="app.regex.tools.title"/>
  section at the end of this appendix provides a few starting points to
  explore advanced or complex uses beyond the scope of this manual. If you need help for a specific case, you can also ask questions in the various support channels.</para>
  
  <para>Regular expressions generally use a combination of letters,
  digits, and symbols (collectively known as
  <emphasis>characters</emphasis>) to define an
  <emphasis>expression</emphasis> that represents a specific text
  pattern.</para>

  <para>Here are a few examples.
  <variablelist>
    <varlistentry>
      <term>[0-9]</term>
      <listitem><para>Any single digit from 0 to 9.</para>
      </listitem>
    </varlistentry>
    <varlistentry>
      <term>\w+</term>
      <listitem><para>Represents one or more “word characters”, namely
      the letters of the alphabet, digits, as well as the hyphen and
      underscore symbols.</para>
      </listitem>
    </varlistentry>
    <varlistentry>
      <term>\h?</term>
      <listitem><para>Represents zero or one horizontal whitespace
      character (this includes regular and non-breaking spaces as well as
      tabs, but not line break characters, which belong to the “vertical
      whitespace” category (\v).)</para>
      </listitem>
    </varlistentry>
  </variablelist>    
  </para>
  
  <para>Many OmegaT functions rely on regular expressions or make them
  available as an option:

  <variablelist>
    <varlistentry>
      <term>Searches</term>
      <listitem>
        <para>OmegaT searches include a <link
        linkend="windows.text.search.methods.regex"
        endterm="windows.text.search.methods.regex.title"/> option that
        allows you to make extremely powerful searches across your
        files.</para>
        <para>The same option in the <link linkend="windows.text.replace"
        endterm="windows.text.replace.title"/> dialog allows you to apply
        regular expressions to both the search and replaced text.</para>
      </listitem>
    </varlistentry>

    <varlistentry>
      <term>Custom tags</term>
      <listitem>
        <para>Custom tags are tags defined with regular expressions that 
        are handled exactly like native OmegaT tags. See <link
        linkend="dialogs.preferences.tag.processing.regular.expressions.for.custom.tags"
        endterm="dialogs.preferences.tag.processing.regular.expressions.for.custom.tags.title"/> 
        for details.</para>
        <para>Use the <code>|</code> (OR) character to separate individual
        tag definitions.</para>
      </listitem>
    </varlistentry>

    <varlistentry>
      <term>Flagged fragments</term>
      <listitem>
        <para><link
        linkend="dialogs.preferences.tag.processing.regular.expressions.for.fragments.that.should.be.removed.from.translation"
        endterm="dialogs.preferences.tag.processing.regular.expressions.for.fragments.that.should.be.removed.from.translation.title"/>
        allow you to define strings that OmegaT will mark in red by
        default, and treat as extraneous tags for validation
        purposes.</para>
        <para>Use the <code>|</code> (OR) character to separate individual
        fragment definitions.</para>
      </listitem>
    </varlistentry>

    <varlistentry>
      <term>Segmentation</term>
      <listitem>
        <para>Segmentation rules and language patterns are defined with
        regular expressions. You can modify them freely to improve the
        segmentation of a document or add additional general rules. See
        <link linkend="dialogs.preferences.segmentation.setup"
			  endterm="dialogs.preferences.segmentation.setup.title"/> for
        details.</para>
        <para>Segmentation or exception rules define the position in a
        segment where a split will, or will not, be made. Two regular
        expressions are required to define that position: a “before”
        expression to define the text pattern ahead of where the rule
        should apply, and an “after” expression to define the text 
        pattern following that position.</para>
      <para>A language pattern that matches the source language of the project will apply to that project.</para></listitem>
    </varlistentry>
  </variablelist>
  </para>

  <section id="app.regexp.four.rules">
	<title id="app.regexp.four.rules.title">The 4 rules</title>

	<para>Regular expressions are used to find text (including characters,
	such as spaces, tabs, or line breaks that are not visible on the screen
	or when printed out. Any given expression either
	<emphasis>matches</emphasis>, or <emphasis>does <emphasis
	role="bold">not</emphasis> match</emphasis> a word, phrase, or other
	sequence of text.</para>
	
	<para>Each and every character in the expression is relevant when
	determining a match.</para>
	<para>A number of characters or combinations of characters have a
	special meaning in a regular expression.</para>
	
	<warning>
      <para>Text decorations such as <emphasis>bold</emphasis>,
      <emphasis>italics</emphasis>, or other <emphasis>stylistic
      effects</emphasis> cannot be matched using regular expressions.</para>
	</warning>

	<para>There are four rules to keep in mind.</para>

	<variablelist>
	  <varlistentry>
		<term>Most characters simply match themselves</term>
		<listitem>
          <para>The majority of characters in a regular expression simply
          <emphasis>look for themselves</emphasis> in the text sequence.</para>
          <para>For example, the seven letters spelling out the word
          “<emphasis>example</emphasis>” simply tell the search function to
          match exactly those letters, in that order. Simply put, the search
          just looks for the word “<emphasis>example</emphasis>”.</para>
		</listitem>
      </varlistentry>

      <varlistentry>
		<term>Letters of the alphabet preceded by a blackslash
		(<literal>\</literal>) take on a special meaning</term>
		<listitem>
          <para>Unlike a letter on its own, which simply represents itself
          as noted above, a letter preceded by a <literal>\</literal> has a
          special function in a regular expression.</para>
          <para>For example, <emphasis>r</emphasis> is just a normal
          character but preceding it with <literal>\</literal> to make it
          <literal>\r</literal> turns it into a special combination
          that matches a  <emphasis>carriage return character</emphasis>.
          Similarly, <literal>\R</literal> matches <emphasis>any line
          break character</emphasis>).</para>
          <note>
			<para>Only the letters <emphasis>i j l m o</emphasis>, and
			<emphasis>y</emphasis>, in both lower- and uppercase, have no special
			meaning when preceded by a backslash. This manual describes only a
			small part of the special meanings of all the other characters.</para>
			
			<para>Consult the sites in the <link linkend="app.regex.tools"
			endterm="app.regex.tools.title"/> section below for information on
			combinations not covered here.</para>
          </note>
		</listitem>
      </varlistentry>
      
      <varlistentry>
		<term>Twelve characters have a special meaning by default</term>
		<listitem>
          <para>That special meaning has to be cancelled by another
          character to match the character itself.</para>
          <para>For example, <literal>.</literal> on its own has the
          special meaning of matching <emphasis>any single character</emphasis>.</para>
          <para>To find a normal period, that meaning has to be cancelled
          using the <literal>\</literal>, to make the expression
          <literal>\.</literal>, which just matches a period.</para>
		</listitem>
	  </varlistentry>

	  <varlistentry>
		<term>The <literal>\</literal> character is a very special
		character</term>
		<listitem>
		  <para>As stated above, the <literal>\</literal> character has the
		  default special meaning of either cancelling or activating the
		  special meaning of other characters. It has no effect if placed
		  before a character with no special meaning (either by default or by addition).</para>
		  <para>The <literal>\</literal> can be disabled by another
		  <literal>\</literal>, as in <literal>\\</literal> to simply match
		  itself as the <emphasis>backslash</emphasis> character.</para>
		</listitem>
	  </varlistentry>
	</variablelist>
  </section>

  <section id="app.regexp.twelve.characters">
	<title id="app.regexp.twelve.characters.title">The 12 characters</title>
	
    <para>The twelve special characters are the
    <emphasis>backslash</emphasis> <literal>\</literal>, the
    <emphasis>caret</emphasis> <literal>^</literal>, the <emphasis>dollar
    sign</emphasis> <literal>$</literal>, the <emphasis>period</emphasis>
    (or <emphasis>dot</emphasis>) <literal>.</literal>, the
    <emphasis>vertical bar</emphasis> (or <emphasis>pipe symbol</emphasis>)
    <literal>|</literal>, the <emphasis>question mark</emphasis>
    <literal>?</literal>, the <emphasis>asterisk</emphasis> (or
    <emphasis>star</emphasis>) <literal>*</literal>, the <emphasis>plus
    sign</emphasis> <literal>+</literal>, the opening and closing <emphasis>parentheses</emphasis>
    <literal>( )</literal>, the opening square bracket <literal>[</literal>, and
    <emphasis>curly brace</emphasis> <literal>{</literal>.
    
	<variablelist>
      <varlistentry>
        <term>The BACKSLASH: <literal>\</literal></term>
        <listitem>
          <para>This character either cancels or activates the special meaning of the following character.
          <example>
            <title>Canceling a special meaning</title>
            <para><literal>\.</literal> cancels the period's special
            meaning of matching any one character, and turns it into a
            plain period.</para>
          </example>
          <example>
            <title>Activating a special meaning</title>
            <para><literal>\b</literal> is no longer just the letter
            “b”, but instead becomes a marker for word boundaries.</para>
          </example>
          </para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>The CARET: <literal>^</literal></term>
        <listitem>
          <para>When it is the first character in the expression, the
          <emphasis>caret</emphasis> character matches the beginning of
          a line.
          <example>
            <title>Matching the beginning of a line.</title>
            <para><literal>^A</literal> matches an uppercase A at
            the beginning of a line.</para>
          </example>
          </para>
          <para>When it is the first character of an expression enclosed
          in square brackets, the <emphasis>caret</emphasis> negates the
          characters that follow.
          <example>
            <title>Negating characters</title>
            <para><literal>[^abc]</literal> matches any characters <emphasis role="bold">other</emphasis> than "a", "b", or "c".</para>
          </example>
          </para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>The DOLLAR sign: <literal>$</literal></term>
        <listitem>
          <para>When it As the last character in an expression, the <emphasis>dollar</emphasis> sign matches the end of a line.
          <example>
            <title>Matching the end of the line</title>
            <para><literal>^$</literal> Matches an empty line
            (there is nothing between the beginning and the end of the
            line).</para>
          </example>
          </para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>The PERIOD: <literal>.</literal></term>
        <listitem>
          <para>Matches any single character.
          <example><title>Matching any character</title>
          <para><emphasis role="bold">^...$</emphasis> = A line
          consisting of a sequence of any three characters.</para>
          </example>
          </para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>The VERTICAL BAR: <literal>|</literal></term>
        <listitem>
          <para>This character functions as an “OR” and matches either
          of the expressions that precede or follow it.
          <example>
            <title>Choosing between alternatives</title>
            <para><literal>^An&nbsp;|^The&nbsp;</literal>
            matches <emphasis>either</emphasis> the sequence “An ”
            <emphasis>or</emphasis> the sequence “The ” (including
            the space) at the beginning of a line.</para>
          </example>
          </para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>The QUESTION MARK: <literal>?</literal></term>
        <listitem>
          <para>This character specifies that either zero or one
          instance of the preceding character or expression should be
          matched.
          <example>
            <title>Matching either the “a" or “an" form of the
            indefinite article</title>
            <para><literal>&nbsp;an?&nbsp;</literal> matches a
            space, followed by the letter “a”, followed by 0 or 1
            instances of the letter “n”, followed by a space.</para>
          </example>
          </para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>The ASTERISK: <literal>*</literal></term>
        <listitem>
          <para>This character specifies that zero or more instances of
          the preceding character or expression should be matched
          <example>
            <title>Matching zero or more characters than can be part
            of a word</title>
            <para><literal>\w+</literal> matches zero or more
            <emphasis>word</emphasis> characters.</para>
          </example>
          </para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>The PLUS sign: <literal>+</literal></term>
        <listitem>
          <para>This character specifies that one or more instances of
          the preceding character or expression should be matched.
          <example>
            <title>Matching multiple whitespace characters</title>
            <para><literal>[\h\v]+</literal> matches one or more
            instances of either a horizontal white or vertical
            whitespace.</para>
          </example>
          </para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>The PARENTHESES: <literal>(   )</literal></term>
        <listitem>
          <para>Enclosing a set of characters in PARENTHESES identifies
          it as a <emphasis>group</emphasis>. The contents of the group
          are stored in memory and can be reused later. Parentheses are
          always used in opening and closing pairs. Trying to use only
          the opening or closing parenthesis on its own will cause an error.
          <example>
            <title>Doubled up words</title>
            <para><literal>(\b\w+\b)\h\1\b</literal> matches a group
            of characters starting after a word boundary (the first
            <literal>\b</literal>) followed by one or more WORD
            characters, and ending at another word boundary (the
            second <literal>\b</literal>).</para>
			<para>The group is followed by a
            horizontal whitespace, and then by the contents of the
            group (the word matched earlier), which is followed by a
            word boundary.</para>
			<para>Therefore, the entire expression matches
            a word followed by itself.</para>
          </example>
          </para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>The opening SQUARE BRACKET: <literal>[</literal></term>
        <listitem>
          <para>Usually comes with the closing square bracket <literal>]</literal>, which does not
          trigger an error on its own.</para>
		  <para>As a pair, they enclose a set of
          individual characters that each constitute a valid match.
          <example>
            <title>How do you spell license?</title>
            <para><literal>li[cs]en[cs]e</literal> matches the
            valid “license” and “licence” spellings, as well as the
            “lisense” and “lisence” potential misspellings of that
            word.</para>
          </example>
          </para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>The opening CURLY BRACE: <literal>{</literal></term>
        <listitem>
          <para>Usually comes with the closing curly brace <literal>}</literal>, which does not
          trigger an error on its own.</para>
		  <para>As a pair, they enclose an
          <emphasis>exact number</emphasis>, <emphasis>minimum</emphasis>,
          <emphasis>maximum</emphasis>, or <emphasis>range</emphasis> specifying
          how many instances of the preceding character or group should be
          matched.
          <example>
            <title>Repetition marker</title>
            <para><literal>\d{4}/\d{1,}</literal> matches a string
            consisting of exactly four digits followed by a / and
            then one or more digits.</para>
          </example>
          </para>
        </listitem>
      </varlistentry>
    </variablelist>
  </para>
</section>

<section id="app.regexp.many.expressions">
  <title id="app.regexp.many.expressions.title">The many expressions</title>

  <warning><para>As seen above, all the characters that come with a preceeding <literal>\</literal> are an expression that means: <emphasis>not the character itself, but the associated special effect</emphasis>.</para></warning>
  
  <table id="app.regex.characters">
    <title id="app.regex.characters.title">Characters</title>

    <tgroup align="left" cols="2" rowsep="1">
      <colspec align="left" colnum="1"/>

      <thead>
        <row>
          <entry align="left">Expression</entry>
          <entry align="left">Match</entry>
        </row>
      </thead>

      <tbody>
        <row>
          <entry>x</entry>
          <entry>The character x itself
		  <para>Most characters match themselves.</para></entry>
        </row>


        <row>
          <entry>\t</entry>
          <entry>The tab character, not "t".</entry>
        </row>

        <row>
          <entry>\n</entry>
          <entry>The newline (line feed) character, not "n".</entry>
        </row>

        <row>
          <entry>\r</entry>
          <entry>The carriage-return character, not "r".
		  <para>\R is any line break character.</para></entry>
        </row>
	  </tbody>
	</tgroup>
  </table>

  <table id="app.regex.classes">
    <title id="app.regex.classes.title">Case and classes</title>

	<note><para>In OmegaT a search is by default case-insensitive: it will match upper-case characters as well as lower-case characters, and you can enable case sensitivity as an option for the whole search.</para>

	<para>But if you want finer settings, you can mix <emphasis
	role="bold">(?i)</emphasis> before case-insensitive parts and <emphasis
	role="bold">(?-i)</emphasis> before case sensitive parts.</para>

	<para><emphasis role="bold">(?i)o(?-i)megat</emphasis> is a case-insensitive “o” followed by a case sensitive “megat”.</para>

	</note>

    <tgroup align="left" cols="2" rowsep="1">
      <colspec align="left" colnum="1"/>

      <thead>
        <row>
          <entry align="left">Expression</entry>
          <entry align="left">Match</entry>
        </row>
      </thead>

      <tbody>
        <row>
          <entry>\w</entry>
          <entry>A word character, generally defined as [A-Za-z0-9_], not "w".
		  <para>\W is NOT a word character ([^\w]).</para></entry>
        </row>

        <row>
          <entry>\d</entry>
          <entry>A digit, generally defined as [0-9].
		  <para>\D is NOT a digit ([^\d]).</para></entry>
        </row>

        <row>
          <entry>\s</entry>
          <entry>A white space that includes spaces, tabs, line breaks, etc., not "s"
		  <para>\S is NOT a whitespace character ([^\s]).</para></entry>
        </row>

        <row>
          <entry>\h and \v</entry>
          <entry>Horizontal and vertical white space (generally preferred to \s), neither "h" nor "v".
		  <para>\H is NOT a horizontal white space and \V is NOT a vertical white space ([^\h] and [^\v]).</para></entry>
        </row>

		<row>
          <entry>[abc]</entry>
          <entry>a, b, or c
		  <para>A simple class is described by any number characters between [ and ]</para></entry>
        </row>

        <row>
          <entry>[C-X]</entry>
          <entry>A character among the “C through X” letters set
		  <para>A range is described by a character that starts a series, followed by a hyphen, followed by a character that ends the series. Any number of ranges can be defined this way: [a-zA-Z0-9]. A hyphen that is outside a series is a hyphen: [a-z-].</para></entry>
        </row>

        <row>
          <entry>[^\n\r\t]</entry>
          <entry>Any character <emphasis>except</emphasis> a newline, a carriage return, or a tabulation
		  <para>The CARET excludes what follows it.</para></entry>
        </row>


      </tbody>
    </tgroup>
  </table>


  <table id="app.regex.unicode.blocs">
	<title id="app.regex.unicode.blocs.title">Unicode blocks, scripts and
	categories</title>

	<para>Regular expressions are not limited to alphabetic characters and numerals, of course. They cover the whole Unicode character set. To specify character classes outside the alphabetical range, use Unicode blocs, scripts and categories.</para>

	<para>See also <ulink url="https://www.regular-expressions.info/unicode.html">Unicode Regular Expressions</ulink> for a thorough review of Unicode regular expressions</para>
	
	<tgroup align="left" cols="2" rowsep="1">
      <colspec align="left" colnum="1"/>

      <thead>
		<row>
          <entry align="left">Expression</entry>
          <entry align="left">Match</entry>
		</row>
      </thead>

      <tbody>
		<row>
          <entry>\p{InGreek}</entry>
          <entry>A character in the Greek block (<ulink
          url="https://unicode.org/reports/tr18/#Blocks">Unicode block</ulink>)
		  <para>\P{InGreek} is a character NOT in the Greek block</para></entry>
		</row>

		<row>
          <entry>\p{IsHan}</entry>
          <entry>A Han character as found in CJK languages (<ulink
          url="https://unicode.org/reports/tr18/#Script_Property">Unicode script</ulink>)</entry>
		</row>
		
		<row>
          <entry>\p{Lu}</entry>
          <entry>An uppercase letter (<ulink
          url="https://unicode.org/reports/tr18/#General_Category_Property">Unicode category</ulink>)</entry>
		</row>

		<row>
          <entry>\p{Sc}</entry>
          <entry>A currency symbol, another Unicode category</entry>
		</row>

      </tbody>
	</tgroup>
  </table>

  <table id="app.regex.boundary.matchers">
	<title id="app.regex.boundary.matchers.title">Locations</title>

	<para>Locations (boundaries) are not part of the match. They just specify
	where the match should be.</para>
	
	<tgroup align="left" cols="2" rowsep="1">
      <colspec align="left" colnum="1"/>

      <thead>
		<row>
          <entry align="left">Expression</entry>
          <entry align="left">Match</entry>
		</row>
      </thead>

      <tbody>
		<row>
          <entry>^</entry>
          <entry>The beginning of the line</entry>
		</row>

		<row>
          <entry>$</entry>
          <entry>The end of the line</entry>
		</row>

		<row>
          <entry>\b</entry>
          <entry>A word boundary</entry>
		</row>

		<row>
          <entry>\B</entry>
          <entry>NOT a word boundary</entry>
		</row>

		<row>
          <entry>(?=u)</entry>
          <entry>Before the expression “u”</entry>
		</row>

		<row>
          <entry>(?!u)</entry>
          <entry>NOT before the expression “u”</entry>
		</row>

		<row>
          <entry>(?&lt;=q)</entry>
          <entry>After the expression “q”</entry>
		</row>

		<row>
          <entry>(?&lt;!q)</entry>
          <entry>NOT after the expression “q”</entry>
		</row>
		
	  </tbody>
	</tgroup>
  </table>
</section>

<section id="app.regexp.examples">
  <title id="app.regexp.examples.title">Examples</title>
  
  <table id="regex.examples">
    <title id="regex.examples.title">Examples of regular expressions
	that use the expressions above</title>

    <tgroup align="left" cols="2" rowsep="1">
      <colspec align="left" colnum="1"/>

      <thead>
        <row>
          <entry>Regular expression</entry>
          <entry>Finds the following:</entry>
        </row>
      </thead>

      <tbody>
        <row>
          <entry>(\b\w+\b)\s\1\b</entry>
          <entry>double words</entry>
        </row>

        <row>
          <entry>[\.,]\s*[\.,]+</entry>
          <entry>comma or a period, followed by spaces and yet another comma
          or period</entry>
        </row>

        <row>
          <entry>\. \s+$</entry>
          <entry>extra spaces after the period at the end of the line</entry>
        </row>

        <row>
          <entry>\s+a\s+[aeiou]</entry>
          <entry>English: words, beginning with vowels, should generally be
          preceded by &quot;an&quot;, not &quot;a&quot;</entry>
        </row>

        <row>
          <entry>\s+an\s+[^aeiou]</entry>
          <entry>English: the same check as above, but concerning consonants
          (&quot;a&quot;, not &quot;an&quot;)</entry>
        </row>

        <row>
          <entry>\s{2,}</entry>
          <entry>more than one space</entry>
        </row>

        <row>
          <entry>\.[A-Z]</entry>
          <entry>Period, followed by an upper-case letter - possibly a space
          is missing between the period and the start of a new
          sentence?</entry>
        </row>

        <row>
          <entry>\bis\b</entry>
          <entry>search for “is”, not “this” or “isn’t” etc.</entry>
        </row>
      </tbody>
    </tgroup>
  </table>
</section>



<section id="app.regex.tools">
  <title id="app.regex.tools.title">References</title>

  <para>Although OmegaT does not offer fancy coloring for your regular
  expressions, you can get a lot of practice by using the <link linkend="windows.text.search"
  endterm="windows.text.search.title"/> window since OmegaT does color the matching results.</para>

  <para>The Java technical reference is useful as a canonical reference.

  <variablelist>
	<varlistentry id="app.regex.java">
	  <term id="app.regex.java.title"><ulink url="&javaregex;">Java Regex
	  documentation</ulink></term>
	  <listitem><para>The official reference for regular expressions used in
	  Java.</para></listitem>
	</varlistentry>
  </variablelist>
  
  If you want to know more about regular expressions, the two following resources have also proved very useful:

  <variablelist>
	<varlistentry id="app.regex.tools.regex101">
	  <term id="app.regex.tools.regex101.title"><ulink url="https://regex101.com">https://regex101.com</ulink></term>
	  <listitem><para>An online regular expression matcher where you enter the text you want to practice on and the regular expressions that you want to try.</para></listitem>
	</varlistentry>
	<varlistentry id="app.regex.tools.regular.expression.info">
	  <term id="app.regex.tools.regular.expression.info.title"><ulink url="https://www.regular-expressions.info">https://www.regular-expressions.info</ulink></term>
	  <listitem><para>One of the most thorough regular expression references on the web.</para></listitem>
	</varlistentry>
  </variablelist>

  OmegaT does not support either site in any way and if you find interesting references in your language, we would love to hear about them.
  </para>
</section>
</section>
